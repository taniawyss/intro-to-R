# We can create a dataframe from its individual column (each one is a vector)
name <- c("Joyce", "Chaucer", "Homer") # creates the vector "name"
status <- c("dead", "deader", "deadest") # creates the vector "status"
reader_rating <- c(55, 22, 100) # creates the vector "reader_rating"
# Here we use the data.frame function to create a data frame! Here you can
# see that a data frame is a two-dimensional combination of vectors.
poets <- data.frame(name, status, reader_rating) # create the df
class(poets)
# Explore the data.frame by calling its name:
poets
poets[2,2] # gets the element on row 2 in column 2
poets[,c(1,3)] # using vectors, we get all rows of columns 1 and 3
poets[,c("name", "reader_rating")] # using a vector of column names, we get
# Another way to access a column by its name is to use the $ sign appended
# to the df name:
poets$name # gets column "name"
# We can perform operations with the columns of a data frame, just like with
# regular vectors
poets$reader_rating/2
# Functions exist to extract or set the row names and column names of a data frame:
rownames(poets) # gets the row names
colnames(poets) # gets the column names
# We can set the row names by providing a vector that will replace
# the current row names. The same can be done for column names.
rownames(poets) <- c("J", "C", "H") # overwrites row names
# Creating matrices using `matrix()` function.
# The first argument is the collection of elements to arrange in the matrix, then
# we specify the number of rows and columns (by default nrow=1 and ncol=1)
# By default the matrix is filled by columns.
my_matrix <- matrix(data = c(10, 0, 20, 5, 6, 1), nrow = 2, ncol = 3)
# If you want to fill the matrix by row, change byrow=TRUE
?matrix()
my_matrix2 <- matrix(data = c(10, 0, 20, 5, 6, 1), nrow = 2, ncol = 3, byrow = T)
# Add row and column names
colnames(my_matrix) <- c("Sample_1","Sample_2","Sample_3")
rownames(my_matrix) <- c("EPCAM","PDGFRB")
my_matrix
# To accessing rows, columns, and individual elements, we can also use the
# square bracket syntax with matrices:
# [rows , columns]
my_matrix[2,2] # gets the element on row 2 in column 2
my_matrix[,c(1,3)] # gets all rows of columns 1 and 3
my_matrix["EPCAM","Sample_2"] # using row names or column names
# ! Unlike with data frames, $ dosen't work with matrices!
# $ dosen't work
my_matrix$Sample_1
# Some R functions require the data to be formatted as a data frame, while
# others require the data to be formatted as a matrix.
# One can convert to / from a data frame:
my_df <- as.data.frame(my_matrix)
class(my_df)
my_matrix <- as.matrix(my_df)
class(my_matrix)
# Let's read a csv file
# ! Check your working directory with getwd() and change the path to where you have saved the file!
# Using the all purpose read.table() function, we need to specify some of the
# arguments to import a csv file.
clinical_data <- read.table("example_clinical_data_03102024.csv",
header=TRUE, sep=",")
# Of course, to import a csv file, we can use the read.csv() function
# Except from the "file" argument, all other arguments can be omitted because
# the defaults are adapted to .csv
clinical_data <- read.csv("example_clinical_data_03102024.csv")
# display first / last rows
head(clinical_data) # shows first 6 rows
tail(clinical_data) # shows last 6 rows
# What are the dimensions of the df
dim(clinical_data) # number of rows and columns
nrow(clinical_data) # number of rows
ncol(clinical_data) # number of columns
# column names
colnames(clinical_data)
# Structure of the data frame: what type is each column? character (chr)?
# integer (int)? numeric (num)? Factor?
str(clinical_data)
# Getting a summary (some statistics)
summary(clinical_data)
# Age has 1 missing value. We decide to remove this MISSING VALUE
# ! Note that this will remove the row with the NA completely!
clinical_data <- na.omit(clinical_data)
summary(clinical_data)
nrow(clinical_data) # number of columns
# Reminder – Accessing parts of the data frame
clinical_data[2,] # 2nd row
clinical_data[, "Age"] # column named "Age"
clinical_data[1:3, c(1,3)] # 3 first rows, 1st and 3rd column
clinical_data$Sample_ID # equivalent to clinical_data[, 1]
clinical_data$Sex[29] # Sex of the last row
# The table() function is
# useful to get a summary of one or several categorical columns
table(clinical_data$Disease)
table(clinical_data$Disease, clinical_data$Sex) # rows are "Disease", columns are "Sex"
subset(clinical_data, Disease=="Tumor")
subset(clinical_data, Disease=="Tumor" & Sex=="female")
subset(clinical_data, Sex=="male" & (Age > 75 | Age < 60))
# Let's add a column
# There are 2 ways to add a column
# 1. Create a new vector that has the same length as the number of rows of your
# data frame, then we use the cbind function to append the new vector to the
# data frame:
# grade <- c(NA,"IV",NA,"III",NA,NA,"IV","I","III","I","III","IV",NA,
#            NA,"III","II","II",NA,"II",NA,NA, NA,"IV","II","III",NA,NA,
#            NA,NA,"I" ) # create new vector
grade <- c(NA,"IV",NA,"III",NA,NA,"IV","I","III","I","III","IV",NA,
NA,"III","II","II",NA,"II",NA,NA, NA,"IV","II","III",NA,NA,
NA,NA ) # create new vector
length(grade) # 29
#clinical_data_mod <- cbind(clinical_data_updated, grade) # bind by column
clinical_data_mod <- cbind(clinical_data, grade) # bind by column
clinical_data_mod <- cbind(clinical_data, grade) # bind by column
# 2. Use the $ sign with a new column name, and use the assignment operator to
# create the new column:
clinical_data_mod$grade_2 <- grade
# Convert "grade" to a factor, and order its levels according to
# increasing severity (and not alphabetically)
clinical_data_mod$grade <- factor(clinical_data_mod$grade, levels = c("I","II","III","IV"))
clinical_data_orig <- clinical_data_mod[,-1] # remove the first column
head(clinical_data_orig) # check resulting data
# extract all columns that you want to keep
clinical_data_orig <- clinical_data_mod[, 2:ncol(clinical_data_mod)]
head(clinical_data_orig) # check resulting data
## Plotting
# Two main options are available within R for plotting.
# Base R plotting functions from the graphics package (comes already pre-installed)
?graphics::plot
# Plotting - the basics
x <- 1:100
y <- log(x) + (x/100)^5
plot(x,y) # equivalent to plot(x, y, type="p")
# Customizing plots
plot(x, y, type="l", col="red",  lwd=3) # this gives a continuous line, of width 3
plot(x, y, type="p", col="cornflowerblue",  pch=17) # this gives blue triangles
abline(a=0, b=1) # adding a continuous line with intercept a=0 and slope b=1
abline(h=3) # adding a horizontal  line with intercept y=3
# Let's clear our Environment first:
rm(list = ls())
install.packages("ggplot2")
library(ggplot2)
# Read in the metadata of tumor cell lines (comes from the paper's supplementary
# files)
metadata <- read.csv("1-s2.0-S1535610818301223-mmc2.csv",
header = TRUE )
# Let's check the Subtypes available
table(metadata$Subtype)
# Convert Subtype to a factor (important for plotting order)
metadata$Subtype <- factor(metadata$Subtype,
levels = c("Undifferentiated", "Neural crest like","Transitory", "Melanocytic"))
class(metadata$Subtype)
# read in the expression data generated for each cell line:
expression_data <- read.table("example_gene_expression_03102024.txt",
header=T)
# Explore the data frame!
expression_data[1:5,1:5]
# Add rownames to the metadata, based on the column "Gene"
rownames(expression_data) <- expression_data$Gene
expression_data[1:5,1:5]
expression_data[1:5, 1:5]
# Remove the column "Gene"
expression_data$Gene <- NULL
expression_data[1:5,1:5]
# convert to a matrix
expression_data <- as.matrix(expression_data)
# are all values numeric?
is.numeric(expression_data) # TRUE
# We need to make sure the categorical df and the continuous gene expression
# df contain the same samples !
metadata$Cell.Line %in% colnames(expression_data)
# Add expression of TMEM9 and SOX10 to the metadata df, extracting the column names
# that correspond to the metadata$Cell.Line
metadata$TMEM9 <- expression_data["TMEM9", metadata$Cell.Line]
metadata$SOX10 <- expression_data["SOX10", metadata$Cell.Line]
str(metadata) # check the format
View(expression_data)
dim(expression_data)
table(metadata$Cell.Line %in% colnames(expression_data))
# Add expression of TMEM9 and SOX10 to the metadata df, extracting the column names
# that correspond to the metadata$Cell.Line
metadata$TMEM9 <- expression_data["TMEM9", metadata$Cell.Line]
metadata$SOX10 <- expression_data["SOX10", metadata$Cell.Line]
str(metadata) # check the format
# We create a basic scatterplot that associates the gene expressions of TMEM9 (x axis) and SOX10 (x axis) and colors by subtype
?ggplot
ggplot(metadata, # the data frame that contains the values to plot
aes(x = TMEM9, # what will be on the x axis
y = SOX10, # what will be on the y axis
color = Subtype)) + # how to group the y values
geom_point()  # additional layer to choose a default scatter plot
# We create a basic boxplot that indicates the expression of SOX10 (y axis) per subtype (x axis)
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
color = Subtype)) + # how to group the y values
geom_boxplot()  # additional layer to choose a default boxplot
# Let's do some additional customization of a boxplot of SOX10
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) + # how to group the y values (note the difference
# when using argument "color" above)
geom_boxplot() +    # additional layer to choose a default box plot
xlab("") +   # leave the x-axis name empty
ylab("Expression level (FPKM)") +    # change the y-axis name
ggtitle("SOX10") + # add a title
theme(legend.position = "none")   # remove the legend
# Let's do some additional customization of a boxplot of SOX10
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) + # how to group the y values (note the difference
# when using argument "color" above)
geom_boxplot() +    # additional layer to choose a default box plot
xlab("") +   # leave the x-axis name empty
ylab("Expression level (FPKM)") +    # change the y-axis name
ggtitle("SOX10") + # add a title
theme(legend.position = "none")   # remove the legend
# Let's try theme_bw()
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) + # how to group the y values (note the difference
# when using argument "color" above)
geom_boxplot() +
xlab("") + # leave the x-axis name empty
ylab("Expression level (FPKM)") + # change the y-axis name
ggtitle("SOX10") + # add a title
theme_bw() # black/white look of plot
# Let's pick a manual color set and change the orientation of the tick labels
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) + # how to group the y values
geom_boxplot() +
scale_fill_manual(values=c("cornflowerblue", "coral", "purple", "lightgreen")) +
xlab("") + # leave the x-axis name empty
ylab("Expression level (FPKM)") + # change the y-axis name
ggtitle("SOX10") +
theme_bw()  + # black/white look of plot
theme(legend.position = "none", axis.text.x= element_text(angle = 90)) # we
# Finally, we can easily separate the boxplot according to an
# additional categorical factor.
# We use the same plot as above:
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) + # how to group the y values
geom_boxplot() +
scale_fill_manual(values=c("cornflowerblue", "coral", "purple", "lightgreen")) +
xlab("") + # leave the x-axis name empty
ylab("Expression level (FPKM)") + # change the y-axis name
ggtitle("SOX10") +
theme_bw()  + # black/white look of plot
theme(legend.position = "none", axis.text.x= element_text(angle = 90)) +
facet_wrap(~Mutation.Status) # make facets according to mutation status
### Multi panel of plots made with ggplot2 and arranged with cowplot.
# We use the same color scheme in both plots, so we can create a
# vector with our colors of choice, and re-use the vector:
color <- c("cornflowerblue", "coral", "purple", "lightgreen")
p1 <- ggplot(metadata,
aes(x = Subtype,
y = SOX10,
fill = Subtype)) +
geom_boxplot() +
scale_fill_manual(values=color) + # use our colors of choice
xlab("") +
ylab("Expression level (FPKM)") +
ggtitle("SOX10") +
theme_bw()  +
theme(legend.position = "none", axis.text.x= element_text(angle = 90))
# Create a customized scatter plot of SOX10 vs TMEM9
p2 <- ggplot(data=metadata, aes(x=TMEM9, y=SOX10, color=Subtype)) +
geom_point() +
scale_color_manual(values=color) +
ggtitle("TMEM9 vs SOX10 expression") +
xlab("TMEM9 (FPKM)") + ylab("SOX10 (FPKM)") +
theme_bw()
# install.packages("cowplot")
library(cowplot)
# we can adapt the relative width of each plot, making one wider as the other:
plot_grid(p1, p2, nrow=1, rel_widths = c(1, 2))
str(metadata) # check the format
# Example 1: boxplot of SOX10:
ggplot(metadata, # the data frame that contains the values to plot
aes(x = Subtype, # what will be on the x axis
y = SOX10, # what will be on the y axis
fill = Subtype)) +
geom_boxplot() +
ggsave(filename = "SOX10_boxplot.pdf")
# Solution
ggplot(metadata, # the data frame that contains the values to plot
aes(x = TMEM9, # what will be on the x axis
y = SOX10, # what will be on the y axis
color = Subtype)) + # how to group the y values
geom_point()  + # additional layer to choose a default scatter plot
scale_color_manual(values=c("cornflowerblue", "coral", "purple", "lightgreen")) +
theme_bw() +
ggtitle("TMEM9 vs SOX10") # title of your choice
# clear the global environment
rm(list = ls())
# Read in the metadata (same as in the plotting section!)
metadata <- read.csv("1-s2.0-S1535610818301223-mmc2.csv",
header = TRUE )
# lets check the subtypes
table(metadata$Subtype)
# subset to "Melanocytic" and "Undifferentiated" subtypes
metadata.sub <- metadata[metadata$Subtype %in% c("Melanocytic","Undifferentiated"),]
# create a factor (important for plotting and in some test functions)
metadata.sub$Subtype <- factor(metadata.sub$Subtype, levels = c("Undifferentiated","Melanocytic"))
class(metadata.sub$Subtype)
# Read in the expression data (same as in the plotting section!)
expression_data <- read.table("example_gene_expression_03102024.txt",
header=T)
# Add rownames to the metadata, based on the column "Gene"
rownames(expression_data) <- expression_data$Gene
# Remove the column "Gene"
expression_data$Gene <- NULL
# convert from a data.frame to a matrix
expression_data <- as.matrix(expression_data)
# create separate vectors of expression of TMEM9 in Undifferentiated and Melanocytic
metadata.sub$Cell.Line %in% colnames(expression_data) # check if samples are present in matrix
Melanocytic_cell_lines <- metadata.sub$Cell.Line[metadata.sub$Subtype=="Melanocytic"]
Undifferentiated_cell_lines <- metadata.sub$Cell.Line[metadata.sub$Subtype=="Undifferentiated"]
TMEM9_expression_Melanocytic <- expression_data["TMEM9",Melanocytic_cell_lines]
TMEM9_expression_Undifferentiated <- expression_data["TMEM9",Undifferentiated_cell_lines]
# Histogram - Melanocytic
# hist() is a base graphics function. For customization of the plot, we change
# the arguments within the hist() function.
hist(TMEM9_expression_Melanocytic, # continuous values to be plotted on the histogram
xlab="FPKM", # to change the x-axis name
main="TMEM9 - Melanocytic") # to change the title
# Quantile-Quantile Plots - Melanocytic
qqnorm(TMEM9_expression_Melanocytic) # this function uses base graphics functions!
qqline(TMEM9_expression_Melanocytic) # the QQ line as added on top of the
# Shapiro-Wilk test of normality - Melanocytic
shapiro.test(TMEM9_expression_Melanocytic)
# Histogram - Undifferentiated
hist(TMEM9_expression_Undifferentiated,
xlab="FPKM",
main="TMEM9 - Undifferentiated")
# Quantile-Quantile Plots - Undifferentiated
qqnorm(TMEM9_expression_Undifferentiated)
qqline(TMEM9_expression_Undifferentiated)
# Shapiro-Wilk test of normality - Undifferentiated
shapiro.test(TMEM9_expression_Undifferentiated)
?t.test
t.test(TMEM9_expression_Melanocytic,
TMEM9_expression_Undifferentiated)
# t.test() and other tests return a list that can be assigned to a variable
test_res <- t.test(TMEM9_expression_Melanocytic,
TMEM9_expression_Undifferentiated)
# View the names of the list’s slots using names().
names(test_res)
# Access the elements of a list using the $ or the [[ ]] operators.
test_res[['p.value']]
# add expression of TMEM9 to the metadata df
metadata.sub$TMEM9 <- expression_data["TMEM9", metadata.sub$Cell.Line]
head(metadata.sub) # check
# run the t.test
t.test(TMEM9 ~ Subtype, data=metadata.sub)
library(ggplot2)
ggplot(metadata.sub, aes(x=Subtype, y=TMEM9, fill=Subtype)) +
geom_boxplot() +
ylab("FPKM") +
ggtitle("TMEM9")
# add results of t.test
library(ggpubr)
ggplot(metadata.sub, aes(x=Subtype, y=TMEM9, fill=Subtype)) +
geom_boxplot() +
stat_compare_means(method = "t.test") + # this function comes from the
# ggpubr package
ylab("FPKM") +
ggtitle("TMEM9")
# Add SOX10 expression to the metadata
metadata.sub$SOX10 <- expression_data["SOX10",metadata.sub$Cell.Line]
head(metadata.sub)
# Check normality - Melanocytic
SOX10_expression_Melanocytic <- metadata.sub$SOX10[metadata.sub$Subtype=="Melanocytic"]
hist(SOX10_expression_Melanocytic,
xlab="FPKM",
main="SOX10 - Melanocytic")
qqnorm(SOX10_expression_Melanocytic)
qqline(SOX10_expression_Melanocytic)
shapiro.test(SOX10_expression_Melanocytic)
# Check normality - Undifferentiated
SOX10_expression_Undifferentiated <- metadata.sub$SOX10[metadata.sub$Subtype=="Undifferentiated"]
hist(SOX10_expression_Undifferentiated,
xlab="FPKM",
main="SOX10 - Undifferentiated")
# Quantile-Quantile Plots - Undifferentiated
qqnorm(SOX10_expression_Undifferentiated)
qqline(SOX10_expression_Undifferentiated)
# Shapiro-Wilk test of normality - Undifferentiated
shapiro.test(SOX10_expression_Undifferentiated)
?wilcox.test
test_res <- wilcox.test(SOX10 ~ Subtype, data=metadata.sub)
test_res
names(test_res)
test_res[["p.value"]]
ggplot(metadata.sub, aes(x=Subtype, y=SOX10, color=Subtype)) +
geom_boxplot() +
stat_compare_means(method = "wilcox") + # function from the ggpubr package
ylab("FPKM") +
ggtitle("SOX10")
metadata.sub$MITF <- expression_data["MITF",metadata.sub$Cell.Line]
# Check normality - Melanocytic
MITF_expression_Melanocytic <- metadata.sub$MITF[metadata.sub$Subtype=="Melanocytic"]
hist(MITF_expression_Melanocytic,xlab="FPKM",main="MITF")
qqnorm(MITF_expression_Melanocytic)
qqline(MITF_expression_Melanocytic)
shapiro.test(MITF_expression_Melanocytic)
# Check normality - Undifferentiated
MITF_expression_Undifferentiated <- metadata.sub$MITF[metadata.sub$Subtype=="Undifferentiated"]
hist(MITF_expression_Undifferentiated,xlab="FPKM",main="MITF")
qqnorm(MITF_expression_Undifferentiated)
qqline(MITF_expression_Undifferentiated)
shapiro.test(MITF_expression_Undifferentiated)
t.test(MITF ~ Subtype, data=metadata.sub) # p-value = 2.665e-08
wilcox.test(MITF ~ Subtype, data=metadata.sub) # p-value = 2.371e-07
ggplot(metadata.sub, aes(x=Subtype, y=MITF, color=Subtype)) +
geom_boxplot() +
stat_compare_means(method = "t.test") +
ylab("FPKM") +
ggtitle("MITF")
# load Edgar Anderson's Iris Data
data(iris)
?iris
# check
head(iris)
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width)) +
geom_point()
# add a trend line
?stat_smooth
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width)) +
geom_point() +
stat_smooth(method="lm") # this function comes from the ggplot2 package
# remove the Standard error around the trend line and change color
?stat_smooth
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width)) +
geom_point() +
stat_smooth(method="lm", se=FALSE, color="red")
# color the dots according to species
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width, color=Species)) +
geom_point() +
stat_smooth(method="lm",se=FALSE, color="red")
# trend line and color per species
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width, color=Species)) +
geom_point() +
stat_smooth(aes(color=Species), method="lm", se=FALSE)
?cor
# correlation coefficient
cor(iris$Petal.Length,iris$Petal.Width, method = "pearson" )
?cor.test
cor.test(iris$Petal.Length,iris$Petal.Width, method = "pearson" )
test_res <- cor.test(iris$Petal.Length,iris$Petal.Width, method = "pearson" )
names(test_res)
# retrieve the correlation coefficient
test_res[["estimate"]]
# retrieve the p.value
test_res[["p.value"]]
# add to the scatterplot
ggplot(data = iris, aes(x= Petal.Length, y=Petal.Width)) +
geom_point() +
stat_smooth(method="lm", se=FALSE, color="red") +
annotate("text", x = 2, y = 2.5,
label = paste("r =",
round(test_res[["estimate"]], 2)),
hjust = 0.5, vjust = 0.5) +
theme_classic()
# Read the expression and the clinical data
expression_data <- read.table("ALL_expression_matrix.txt", header = T)
expression_data <- as.matrix(expression_data)
clinical_data <- read.csv("ALL_clinical_data.csv")
# check the clinical data
summary(clinical_data)
# Add expression of STOM to the clinical_data df
clinical_data$STOM <- expression_data["STOM", clinical_data$cod]
head(clinical_data)
# Create a scatter plot
ggplot(clinical_data, aes(x=age,y=STOM)) +
geom_point()
my_model <- lm(STOM~age, data=clinical_data)
my_model
# representation of the fit
ggplot(clinical_data, aes(x=age,y=STOM)) +
geom_point() +
geom_smooth(method = "lm", se=FALSE) + xlim(0,60)
# Residuals
residuals(my_model) # extracts a vector containing the residuals (error)
# Several plots
par(mfrow=c(2,2)) # this function prepares the plotting window to receive 4
# plots generated with base graphics and to organize them into a panel of 2
# rows and 2 columns. The par() function is usually called just before calling
# the plot() functions.
plot(my_model) # the base plot() function can also take as argument a linear
summary(my_model)
library(MASS) # Load the package MASS using library().
data(Pima.tr) # Load the dataset Pima.tr using data(Pima.tr).
?Pima.tr # Use ? to get an idea which variables it contains.
# Run a linear model to test the hypothesis.
my_model <- lm(bp ~ glu, data = Pima.tr)
summary(my_model)
# Visualize the fit with a scatter plot and a trend line
ggplot(Pima.tr, aes(x=glu, y=bp)) +
geom_point() +
geom_smooth(method = "lm", se=FALSE) +
ggtitle("Blood pressure vs glucose") +
xlab("Plasma glucose concentration") +
ylab("Diastolic blood pressure")
# Check assumptions of the model graphically
par(mfrow=c(2,2))
plot(my_model)
sessinInfo()
sessionInfo()
